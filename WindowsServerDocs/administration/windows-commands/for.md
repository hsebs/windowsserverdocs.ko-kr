---
title: for
description: '* * * *에 대 한 참조 항목'
ms.prod: windows-server
ms.technology: manage-windows-commands
ms.topic: article
ms.assetid: e275726c-035f-4a74-8062-013c37f5ded1
author: coreyp-at-msft
ms.author: coreyp
manager: dongill
ms.date: 10/16/2017
ms.openlocfilehash: f13f6c4b98af141d19782d297200dfd18ab65ff0
ms.sourcegitcommit: ab64dc83fca28039416c26226815502d0193500c
ms.translationtype: MT
ms.contentlocale: ko-KR
ms.lasthandoff: 05/01/2020
ms.locfileid: "82725580"
---
# <a name="for"></a>for



파일 집합에 각 파일에 대해 지정된 된 명령을 실행합니다.



## <a name="syntax"></a>구문

```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```

### <a name="parameters"></a>매개 변수

|매개 변수|설명|
|---------|-----------|
|{%%\|%} \<변수>|필수 사항입니다. 대체 가능 매개 변수를 나타냅니다. 단일 백분율 기호 (**%**)를 사용 하 여 명령 프롬프트에서 **for** 명령을 수행 합니다. 일괄 처리 파일 내에서**%%** **for** 명령을 수행 하려면 double 백분율 기호 ()를 사용 합니다. 변수는 대/소문자를 구분 하 고 나타내야 영문자 값와 같은 **%a**, **%b**, 또는 **%c**합니다.|
|(\<> 설정)|필수 사항입니다. 하나 이상의 파일, 디렉터리 또는 텍스트 문자열 또는 명령을 실행 하는 데 기반이 값의 범위를 지정 합니다. 괄호가 필요합니다.|
|\<명령>|필수 사항입니다. 에 포함 된 값의 범위 또는 각 파일, 디렉터리 또는 텍스트 문자열에서 체크 아웃 수행 하려는 명령을 지정 *설정*합니다.|
|\<CommandLineOptions>|지정된 된 명령을 사용 하려면 명령줄 옵션을 지정 합니다.|
|/?|명령 프롬프트에 도움말을 표시합니다.|

## <a name="remarks"></a>설명

- 사용 **방법**

  배치 파일 내에서 또는 명령 프롬프트에서 **직접 명령 프롬프트를 사용할** 수 있습니다.
- 일괄 처리 매개 변수 사용

  **For** 명령에 적용 되는 특성은 다음과 같습니다.  
  - **에 대 한** 대체 명령 **%**<em>변수</em> 또는 **%%**<em>변수</em> 지정된 된 모든 파일을 처리할 때까지 지정된 된 집합의 각 텍스트 문자열입니다.
  - 변수 이름은 대/소문자 구분, 글로벌 및 52 한 번에 수 있는 것 보다 더 이상있지 않습니다.
  - 일괄 처리 매개 변수를 사용 하 여 혼동을 피하기 위해 **%0** 통해 **9**, 에 대 한 모든 문자를 사용할 수 있습니다 *변수* 숫자 0-9 제외 하 고 있습니다. 간단한 배치 파일을 단일 문자 같은 **%%1** 작동 합니다.
  - 에 대 한 여러 값을 사용할 수 있습니다 *변수* 대체 가능한 다른 변수들을 구분 하기 위해 복잡 한 배치 파일에 있습니다.
- 파일 그룹 지정

  *Set* 매개 변수는 단일 파일 그룹 또는 여러 파일 그룹을 나타낼 수 있습니다. 와일드 카드 문자 (**&#42;** 및 **?**)를 사용 하 여 파일 집합을 지정할 수 있습니다. 다음은 유효한 파일 집합입니다.  
  ```
  (*.doc) 
  (*.doc *.txt *.me)
  (jan*.doc jan*.rpt feb*.doc feb*.rpt)
  (ar??1991.* ap??1991.*)
  ```  
  사용 하는 경우는 **에 대 한** 명령, 첫 번째 값 *설정* 대체 **%**<em>변수</em> 또는 **%%**<em>변수</em>, 지정된 된이이 값을 처리 합니다. 모든 파일 (또는 파일 그룹)에 해당 하는 때까지 계속는 *설정* 값 처리 됩니다.
- **In** 및 **do** 키워드 사용

  **및은** 매개 변수가 아니지만 **에 대해** **이 매개** 변수를 사용 해야 합니다. 이러한 키워드를 생략 하면 오류 메시지가 나타납니다.
- **의 추가** 양식 사용

  명령 확장을 사용 하는 경우 (기본값) **에 대해** 다음과 같은 추가 형식이 지원 됩니다.  
  - 디렉터리만

    *Set* 에 와일드 카드 문자 (**&#42;** 또는 **?**)가 포함 된 경우 지정 된 *명령은* *set*와 일치 하는 지정 된 디렉터리에 있는 파일 집합이 아닌 각 디렉터리에 대해 실행 됩니다.

    구문은 다음과 같습니다.  
    ```
    for /d {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>] 
    ```  
  - Recursive

    *드라이브*:*경로* 를 기반으로 하는 디렉터리 트리를 탐색 하 고 트리의 각 디렉터리에서 **for** 문을 실행 합니다. 디렉터리가 없는 지정 되 면 **/r**, 현재 디렉터리를 루트 디렉터리로 사용 됩니다. 경우 *설정* 단일 마침표 (.)만 디렉터리 트리만 열거 합니다.

    구문은 다음과 같습니다.  
    ```
    for /r [[<Drive>:]<Path>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    ```  
  - 값 범위 반복

    반복 변수를 사용 하 여 시작 값을 설정 (*Start*#) 한 다음 값이 설정 된 끝 값 (*End*#)을 초과할 때까지 값의 집합을 단계별로 실행 합니다. **/l** 비교 하 여 반복 되는 실행 *시작*와 # *끝*#입니다. 경우 *시작*#은 보다 작은 *끝*# 명령을 실행 합니다. 반복 변수를 초과할 때 *끝*#, 명령 셸 루프를 종료 합니다. 음수를 사용할 수도 있습니다 *단계*# 감소 하는 값의 범위를 단계별로 실행 되도록 합니다. 예를 들어, (1,1,5) 1 2 3 4 5 시퀀스를 생성 하 고 (5,-1, 1) 5 4 3 2 1 시퀀스를 생성 합니다.

    구문은 다음과 같습니다.  
    ```
    for /l {%%|%}<Variable> in (<Start#>,<Step#>,<End#>) do <Command> [<CommandLineOptions>]
    ```  
  - 반복 및 파일 구문 분석

    파일 구문 분석을 사용 하 여 명령 출력, 문자열 및 파일 콘텐츠를 처리 합니다.  반복 변수를 사용 하 여 내용이 나 검사 하려는 문자열을 정의 하 고 사용 하 여 다양 한 *ParsingKeywords* 추가 구문 분석을 수정 하는 옵션입니다.  사용 된 *ParsingKeywords* 토큰 지정 반복 변수는 토큰을 전달 해야 하는 옵션입니다. 토큰 옵션 없이 사용할 경우 사용자에 게 유의 **/f** 만 첫 번째 토큰 살펴봅니다.

    파일 구문 분석 하는 작업은 출력, 문자열 또는 파일 내용을 읽는 다음 텍스트의 개별 선으로 분할 하 고 0 개 이상의 토큰으로 구문 분석 되는 각 줄의 구성 됩니다. **에 대 한** 루프 반복 변수 값이 토큰에 설정 된 후 호출 됩니다. 기본적으로 **/f** 각 파일의 각 줄에서 분리 하 고 첫 번째 빈 토큰을 전달 합니다. 빈 줄은 건너뜁니다.

    구문은 다음과 같습니다.  
    ```
    for /f [<ParsingKeywords>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f [<ParsingKeywords>] {%%|%}<Variable> in (<LiteralString>) do <Command> [<CommandLineOptions>]
    for /f [<ParsingKeywords>] {%%|%}<Variable> in ('<Command>') do <Command> [<CommandLineOptions>]
    ```  
    *설정* 인수에는 하나 이상의 파일 이름을 지정 합니다. 각 파일은 열, 읽기 및 처리에 있는 다음 파일을 이동 하기 전에 *설정*합니다. 기본 구문 분석 동작을 재정의 하려면 지정 *ParsingKeywords*합니다. 이것이 다른 구문 분석 옵션을 지정 하려면 하나 이상의 키워드를 포함 하는 따옴표 붙은 문자열입니다.

    사용 하는 경우는 **usebackq** 옵션을 다음 구문 중 하나를 사용 합니다.  
    ```
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in ('<LiteralString>') do <Command> [<CommandLineOptions>]
    for /f [usebackq <ParsingKeywords>] {%%|%}<Variable> in (`<Command>`) do <Command> [<CommandLineOptions>]
    ```  
    다음 표에서 구문 분석에 사용할 수 있는 키워드를 보여 줍니다. *ParsingKeywords*합니다.  

    |      키워드      |                                                                                                                                                                                                          설명                                                                                                                                                                                                          |
    |-------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
    |     eol =\<c>      |                                                                                                                                                                                   한 줄의 끝 문자 (하나의 문자)를 지정합니다.                                                                                                                                                                                    |
    |     skip =\<N>     |                                                                                                                                                                              파일의 시작 부분에 표시 하지 않으려면 줄 수를 지정 합니다.                                                                                                                                                                              |
    |   delims =\<xxx>   |                                                                                                                                                                     구분 기호 집합을 지정합니다. 이 작업 공간 및 탭의 기본 구분 기호 집합을 대체 합니다.                                                                                                                                                                      |
    | 토큰 =\<X, Y, M – N> | 전달 되는 각 줄의 토큰을 지정 된 **에 대 한** 각 반복에 대 한 루프입니다. 결과적으로, 추가 변수 이름이 할당 됩니다. *M*–*N* 에서 범위를 지정 합니다.는 *M*번째부터 *N*번째 토큰입니다. Token **=** string의 마지막 문자가 별표 (**&#42;**) 이면 추가 변수가 할당 되 고 구문 분석 된 마지막 토큰 뒤의 줄에서 나머지 텍스트를 받습니다. |
    |     usebackq      |                                                                                             다음을 지정 합니다. 다시 따옴표 붙은 문자열을 명령으로 실행 하 고, 작은따옴표로 묶은 단일 문자열을 리터럴 문자열로 사용 하거나, 공백을 포함 하는 긴 파일 이름의 경우 * \<Set\>* 의 파일 이름을 큰따옴표로 묶어야 합니다.                                                                                              |


  - 변수 대체

    다음 표에서는 선택적 구문을 나열 합니다 (모든 변수 **I**).  

    |한정자를 사용 하 여 변수|설명|
    |----------------------|-----------|
    |% ~ I|확장 **% I** , 주변 따옴표 ()를 제거 합니다.|
    |% ~ fI|확장 **%i** 정규화 된 경로 이름입니다.|
    |% ~ dI|확장 **%i** 드라이브 문자로 합니다.|
    |% ~ pI|확장 **%i** 만 경로에 있습니다.|
    |% ~ nI|확장 **%i** 만 파일 이름으로 저장 합니다.|
    |% ~ xI|확장 **%i** 파일 이름 확장명으로 합니다.|
    |% ~ sI|짧은 이름만 포함에 대 한 경로 확장 합니다.|
    |% ~ aI|확장 **%i** 파일의 파일 특성입니다.|
    |% ~ tI|확장 **%i** 파일의 시간과 날짜를 합니다.|
    |% ~ zI|확장 **%i** 파일의 크기입니다.|
    |% ~ $PATH: I|PATH 환경 변수에 나열 된 디렉터리를 검색 하 고 확장 **%i** 찾을 첫 번째 디렉터리의 정규화 된 이름에 있습니다. 환경 변수 이름이 정의 되지 않은 경우 파일은 검색에서 찾을 수 없습니다이 한정자는 빈 문자열로 확장 됩니다.|

    다음 표에서 복합 결과 얻는 데 사용할 수 있는 한정자 조합을 나열 합니다.  

    |결합 된 한정자가 포함 된 변수|설명|
    |--------------------------------|-----------|
    |% ~ dpI|확장 **%i** 드라이브 문자와 경로를 합니다.|
    |% ~ nxI|확장 **%i** 파일 이름과 확장명 전용입니다.|
    |% ~ fsI|확장 **%i** 짧은 이름의 전체 경로 이름입니다.|
    |% ~ dp$ 경로: I|에 대 한 PATH 환경 변수에 나열 된 디렉터리를 검색 **%i** 드라이브 문자와 찾은 첫 번째의 경로를 확장 합니다.|
    |% ~ ftzaI|확장 **%i** 유사한 출력 줄에 **dir**합니다.|

    위 예제에서 대체할 수 있습니다 **%i** 및 다른 유효한 값을 가진 경로입니다. 유효한 **에 대 한** 변수 이름 종료는 **%~** 구문입니다.

    예: 변수 이름은 대문자를 사용 하 여 **%i**, 코드를 더 읽기 쉽게 하 고 대 소문자를 구분 하지 않은 한정자와 혼동 되지 않도록 합니다.
- 문자열 구문 분석

  * \<LiteralString\> * 를 큰따옴표 (usebackq*포함* 안 함) 또는 작은따옴표 (usebackq *) (예* : (mystring) 또는 (' mystring '))로 래핑하여 즉시 문자열에 **/f** 구문 분석 논리를 사용할 수 있습니다. LiteralString는 파일에서 한 줄의 입력으로 처리 됩니다. * \<\> * ** \\ \& \| \> \< \^ ** * \<LiteralString\> * 을 큰따옴표로 구문 분석할 때 명령 기호 (예:)는 일반 문자로 처리 됩니다.
- 출력 구문 분석

  **/F** * \<명령을 사용 하면 괄호 사이에\> * 백슬래시 ()를 사용 하 여 명령의 출력을 구문 분석할 수 있습니다. 하위 Cmd.exe에 전달 되는 명령줄으로 처리 됩니다. 출력은 메모리에 캡처되고 파일 처럼 구문 분석 합니다.

## <a name="examples"></a>예

사용 하 여 **에 대 한** 배치 파일에서 다음 구문을 사용 합니다.
```
for {%%|%}<Variable> in (<Set>) do <Command> [<CommandLineOptions>]
```
대체할 수 있는 변수를 사용 하 여 확장명이.doc 또는.txt 있는 현재 디렉터리에 있는 모든 파일의 내용을 표시 하려면 **%f**, 유형:
```
for %f in (*.doc *.txt) do type %f 
```
위의 예제에서는 확장명이.doc 또는.txt 현재 디렉터리에 있는 각 파일에 대 한 대체는 **%f** 모든 파일의 내용이 표시 될 때까지 변수입니다. 배치 파일에서이 명령을 사용 하려면 모든 일치 항목을 바꾸려면 **%f** 와 **%%1**합니다. 그렇지 않으면 변수는 무시 하 고 오류 메시지가 표시 됩니다.

파일을 구문 분석 하려면 무시 하 고 주석 처리 된 줄, 유형:
```
for /f eol=; tokens=2,3* delims=, %i in (myfile.txt) do @echo %i %j %k
```
이 명령은 Myfile.txt의 각 줄을 구문 분석합니다. 세미콜론으로 시작 하는 줄을 무시 하 고 각 줄을에서 두 번째 및 세 번째 토큰을 전달 된 **에 대 한** 본문 (토큰은 쉼표 또는 공백을로 구분 됨). 본문은 **에 대 한** 문 참조 **%i** 토큰을 가져오기 위해 두 번째, **%j** 세 번째 토큰을 가져오려면 및 **%k** 모든 나머지 토큰을 가져오려면. 사용자가 제공 하는 파일 이름에 공백이 포함 된 경우 텍스트에 따옴표를 사용 합니다 (예: 파일 이름). 인용 부호를 사용 하려면 사용 해야 **usebackq**합니다. 그렇지 않으면 따옴표는 리터럴 문자열을 구문 분석을 정의로 해석 됩니다.

**%i** 에 명시적으로 선언 되는 **에 대 한** 문입니다. **%j** 및 **%k** 를 사용 하 여 암시적으로 선언 된 **토큰 =** 합니다. 문자 z 또는 Z 보다 큰 변수를 선언 하려고 시도 하지 않는 경우 token **=** 를 사용 하 여 최대 26 개의 토큰을 지정할 수 있습니다.

현재 환경에서 환경 변수 이름을 열거 합니다. 배치 하 여 명령의 출력을 구문 분석을 *설정* 는 괄호를 입력 합니다.
```
for /f usebackq delims== %i in ('set') do @echo %i 
```

## <a name="additional-references"></a>추가 참조

- [명령줄 구문 키](command-line-syntax-key.md)
